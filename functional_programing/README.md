# 쏙쏙 들어오는 함수형 코딩

![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcawdhc%2Fbtrz8ulSM1C%2FmJ5LPTZmcXWhT7kpwrA6Y0%2Fimg.png)

TIL

## 함수형 프로그래밍을 잘하기 위해서

함수형 프로그래밍을 잘하기 위해서 코드 또는 요구 사항을을 액션, 계산, 데이터로 구분할수 있어야 한다.

## 액션

액션은 부수효과 (Side Effect) 가 있는 함수를 말하며 실행 시점과 실행 횟수에 따라 그 결과값이 달라질수 있다.

그렇기 때문에 액션을 가능한 __적게__ 사용하고 __작게__ 만든다.

## 계산

입력 값으로 출력 깂을 만드는 것이며 실행 시점과 횟수와 상관없이 항상 같은 입력 값에 대해서 같은 출력값을 돌려준다.

계산을 일반적으로 `순수함수` 라고도 부른다.

### 액션보다 계산이 좋은 이유

1. 테스트하기 쉽다.
2. 정적 분석이 쉽다.
3. 조합 하기가 좋다.

## 데이터

이벤트에 대한 사실을 기록

## 데이터

## 액션 개선 방법

- 액션은 암묵적인 입력 또는 출력을 가지고 있다.
- 계산은 암묵적인 입력 또는 출력이 없어야 한다.
- 전역 변수는 일반적으로 암묵적인 입력 또는 출력이 된다.
- 암묵적 입력을 인자로 바꿔라
- 암묵적 출력을 리턴 값을 바꿔라!

## 원칙 : 암묵적 입력과 출력은 적을수록 좋다.

암묵적 입력과 출력이 있는 함수는 아무 때나 실행할 수 없기 때문에 테스트하기 어렵다.

## 원칙 : 설계는 엉켜있는 코드를 푸는 것이다.

- 재사용하기 쉽다.
- 유지보수하기 어렵다.
- 테스트하기 쉽다.

## 카피-온-라이트 원칙 세 단계

1. 복사본 만들기
2. 복사본 변경하기(원하는 만큼)
3. 복사본 리턴하기

## 쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까?

- 읽기와 쓰기 함수로 각각 분리한다.
- 함수에서 값을 두 개 리턴한다.

## 불변 데이터 구조를 읽는 것은 계산이다.

- 변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있다. 따라서 변경 가능한 데이터를 읽는 것은 액션이다.
- 쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다.
- 쓰기를 모두 없앴다면 데이터는 생성 이후 바뀌지 않습니다. 따라서 불변 데이터입니다.
- 어떤 데이터를 불변형으로 만들었다면 그 데이터에 모든 익기는 계산이다.
- 데이터 구조를 불변형으로 만들수록 코드에 더 많은 계산이 생기고 액션은 줄어든다.

## 바꿀 때마다 복사를 하면 너무 비효율적인 것이 아닌가요?

> 불변 데이터 구조는 충분히 빠릅니다.

- 언제든 최적화할 수 있습니다.
- 가비지 콜렉터는 매우 빠릅니다.
- 생각보다 많이 복사하지 않습니다.
- 함수령 프로그래밍 언어에는 빠른 구현체가 있습니다.

## 레거시 코드와 상호작용

우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드(레거시) 와 상호작용을 해야한다.
그래서 데이터가 바뀌는 것을 완벽히 막아주는 원칙이 필요한다. 이 원칙을 __방어적 복사__ 라고 한다.

## 방어적 복사 === Deep Copy

## 방어적 복사 규칙

### 규칙 1: 데이터가 안전한 코드에서 나갈 때 복사하기

1. 불변성 데이터를 위한 깊은 복사본을 만든다.
2. 신뢰할 수 없는 코드로 복사복을 전달

### 규칙 2: 안전한 코드로 데이터가 들어올 때 복사하기

1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달한다.
2. 복사본을 안전한 코드에서 사용한다.

## 카피-온-라이트와 방어적 복사는 비슷한 것 같습니다. 정말 다른 것인가요? 둘 다 필요한가요?

카피-온-라이트와 방어적 복사 모두 불변성을 유지하기 위해서 사용한다. 사실 안전지대에서도 방어적 복사로 불변성을 유지할 수 있다.

하지만 방어적 복사는 카피-온-라이트 보다 더 많은 비용이 든다. 그래서 가능한 안전 지대에서는 카피-온-라이트를 사용하는 것이 좋다. 그래서 두 원칙은 함께 사용해야 한다.

## 계층형 설계 패턴

- 계층형 설계는 소프트웨어를 계층으로 구성하는 기술입니다. 각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의합니다.
- 각 계층을 정확히 구분하기는 어렵습니다. 계층을 잘 구분하려면 구분하기 위한 다양한 변수를 찾고 찾은 것을 가지고 어떻게 해야 하는 지 알아야 합니다.

계층형 설계를 구현할 때 아래의 방법을 이용합니다.

### 패턴 1: 직접 구현

### 패턴 2: 추상화 벽

- 호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공합니다. 고수준의 추상화 단계만 생각하면 되기 때문에 __두뇌의 용량의 한계를 극복할 수 있습니다.__
- 추상화의 벽은 세부 구현을 감춘 함수로 이루어진 계층이다.
- 추상화의 벽이 있으면 구체적인 것을 신경 쓰지 않아도 된다.

### 패턴 3: 작은 인터페이스

시스템이 커질수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다.

### 패턴 4: 편리한 계층

계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 한다. 그냥 좋아서 계층을 추가하면 안된다.

## 추상화의 병은 언제 사용하면 좋을까요?

1. 쉽게 구현을 바꾸기 위해
2. 코드를 읽고 쓰기 쉽게 만들기 위해
3. 팀 간에 조율해야 할 것을 줄이기 위해
4. 주어진 문제에 집중하기 위해

## 기능적 요구 사항

소프트웨어가 정확히 해야하는 일을 말한다. 예를 들어 세금에 대해 계산을 하면 올바른 계산 결과가 나와야 한다.

## 비 기능적 요구 사항

테스트를 어떻게 할 것인지, 재사용을 잘 할수 있는지, 유지보수하기 어렵지 않은지

## 그래프가 코드에 대해 알려 주는 것

<img width="816" alt="image" src="https://user-images.githubusercontent.com/35194820/215329884-e87af01b-1877-4496-a11c-8d9794559968.png">

함수 호출 그래프의 특징은 아래와 같습니다.

### 유지 보수성

위로 연결된 것이 적은 함수가 바꾸기 쉽다.

### 테스트 가능성

위쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치가 있다.

### 재사용성

아래쪽에 함수가 적을수록 더 재사용하기 좋다.

핵심 : 낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아진다.

## 코드의 냄새: 함수 이름에 있는 암묵적 인자

### 냄새를 맡는 법

1. 함수 구현이 거의 똑같습니다.
2. 함수 이름이 구현의 차이를 만듭니다.

> __코드의 냄새__ 는 더 큰 문제를 가져올 수  있는 코드입니다.

## 고차 함수 (High-order function)

인자로 함수를 받거나 리턴 값으로 함수를 리턴할 수 있는 함수를 말합니다.

## 익명함수

이름이 없는 함수입니다. 익명 함수는 필요한 곳에 인라인으로 쓸 수 있습니다.

## 함수 본문을 콜백으로 바꾸는 법

1. 본문과 앞부분, 뒷부분을 확인하기
2. 함수 빼내기
3. 콜백 빼내기

## 고차 함수 요약

- 고차 함수로 패턴이나 원칙을 코드로 만들수 있습니다. 고차 함수는 한번 정의하고 필요한 곳에 여러 번 사용할 수 있습니다.
- 고차 함수로 함수를 리턴하는 함수를 만들수 있습니다.
- 고차 함수를 사용하면서 잃는 것도 있습니다. 고차 함수는 많은 중복 코드를 없애 주지만 가독성을 해칠 수고 있습니다.

## 함수를 전달하는 세 가지 방법

1. 전역적으로 정의하기
2. 지역적으로 정의하기
3. 인라인으로 정의하기

## 함수형 도구 체이닝

하나의 작업을 여러개의 함수형 도구로 여러 단계로 나누고 서로 연결하는 것을 __체이닝__ 이라고 한다.

## 체이닝

- 체인이라고 부르는 방법으로 여러단계를 조합한다.
- 체인의 각 단계는 원하는 결과에 가까워지도록 데이터를 한 단계 씩 변환하는 단순한 동작이다.
- 함수형 도구를 체인을 조합하는 것은 SQL 같은 쿼리 언로로 볼 수 있다. 함수형 도구 체인으로 배열을 다루는 복잡한 쿼리를 표현할수 있다.

### 데이터 만들기

함수형 도구는 배열 전체를 다룰 때 잘 동작합니다.

### 배열 전체를 다루기

map 은 모든 항목을 변환하고 filter() 는 항목을 없애거나 유지한다. reduce() 는 항목을 하나로 합친다.

### 작은 단계로 나누기

알고리즘이 한 번에 너무 많은 일을 한다고 생각된다면 두 개 이상의 단계로 나눠보자!

### 보너스: 조건문을 filter() 로 바꾸기

### 보너스: 유용한 함수로 추출하기

### 보너스: 개선을 위해 실험하기

## 타임라인

시간에 따른 액션의 순서입니다. 여러 개의 타임라인이 동시에 실행되기도 합니다.

## 좋은 타임라인의 원칙

1. 타임라인은 적을수록 이해하기 쉽습니다.
2. 타임라인은 짧을수록 이해하기 쉽습니다.
3. 공유하는 자원이 적을수록 이해하기 쉽습니다.
4. 자원을 공유한다면 서로 조율해야 합니다.
5. 시간을 일급으로 다룹니다.

## 자바스크립트의 비동기 큐

브라우저에서 동작하는 자바스크립트의 엔진은 작업 큐라고 하는 큐를 가지고 있습니다. 작업 큐는 이벤트 루프에 의해 처리됩니다. 이벤트 루프는 큐에서 작업하나를 꺼내 실행하고 완료되면 다음 작업을 꺼내 실행하는 것을 무한히 반복합니다. 이벤트 루프는 하나의 스레드에서 처리하기 때문에 두 개의 작업이 동시에 실행될 수 없습니다.

## Link

http://www.yes24.com/Product/Goods/108748841
